<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REAL-TIME DICOM Canvas Performance Test</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 10px;
            height: 100vh;
        }
        
        .viewer-area {
            border: 1px solid #333;
            position: relative;
        }
        
        .metrics-panel {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            overflow-y: auto;
        }
        
        #test-canvas {
            width: 100%;
            height: 100%;
            background: #000;
            cursor: crosshair;
        }
        
        .metric {
            margin: 5px 0;
            padding: 3px;
            background: #222;
            border-left: 3px solid #00ff00;
        }
        
        .metric.warning {
            border-left-color: #ffaa00;
            color: #ffaa00;
        }
        
        .metric.error {
            border-left-color: #ff0000;
            color: #ff0000;
        }
        
        .controls {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 5px 10px;
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            cursor: pointer;
            font-size: 10px;
        }
        
        button:hover {
            background: #555;
        }
        
        .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="viewer-area">
            <canvas id="test-canvas"></canvas>
            <div class="status" id="status">Loading...</div>
        </div>
        
        <div class="metrics-panel">
            <h3>🎯 REAL-TIME PERFORMANCE METRICS</h3>
            
            <div class="controls">
                <button onclick="startTest()">Start Test</button>
                <button onclick="stopTest()">Stop Test</button>
                <button onclick="generateTestImage()">Test Image</button>
                <button onclick="testZoom()">Test Zoom</button>
                <button onclick="testPan()">Test Pan</button>
                <button onclick="clearCanvas()">Clear</button>
            </div>
            
            <div id="metrics">
                <div class="metric">Status: <span id="test-status">Ready</span></div>
                <div class="metric">FPS: <span id="fps">0</span></div>
                <div class="metric">Render Time: <span id="render-time">0ms</span></div>
                <div class="metric">Canvas Size: <span id="canvas-size">0x0</span></div>
                <div class="metric">Memory Usage: <span id="memory">0MB</span></div>
                <div class="metric">GPU Available: <span id="gpu-status">Unknown</span></div>
                <div class="metric">Image Loaded: <span id="image-status">No</span></div>
                <div class="metric">Interactions: <span id="interactions">0</span></div>
                <div class="metric">Last Action: <span id="last-action">None</span></div>
            </div>
            
            <h4>📊 Performance History</h4>
            <div id="performance-log" style="max-height: 200px; overflow-y: auto; font-size: 10px;"></div>
            
            <h4>🔧 Canvas Tests</h4>
            <div id="test-results" style="max-height: 150px; overflow-y: auto; font-size: 10px;"></div>
        </div>
    </div>

    <script>
        // Real-time performance monitoring
        let canvas, ctx;
        let testRunning = false;
        let animationFrame;
        let frameCount = 0;
        let lastFrameTime = 0;
        let startTime = 0;
        let interactions = 0;
        let currentImage = null;
        
        // Performance tracking
        let renderTimes = [];
        let frameRates = [];
        let performanceLog = [];
        
        // Initialize
        window.addEventListener('load', function() {
            initCanvas();
            setupEventListeners();
            updateStatus('Canvas initialized');
            startPerformanceMonitoring();
        });
        
        function initCanvas() {
            canvas = document.getElementById('test-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Test canvas capabilities
            testCanvasCapabilities();
        }
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            updateMetric('canvas-size', `${canvas.width}x${canvas.height}`);
            
            // Clear and redraw if we have an image
            if (currentImage) {
                drawImage();
            }
        }
        
        function testCanvasCapabilities() {
            const tests = [];
            
            // Test 2D context
            tests.push({
                name: 'Canvas 2D Context',
                result: !!ctx,
                details: ctx ? 'Available' : 'Not available'
            });
            
            // Test WebGL
            let webglCtx;
            try {
                webglCtx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                tests.push({
                    name: 'WebGL Context',
                    result: !!webglCtx,
                    details: webglCtx ? 'Available' : 'Not available'
                });
                updateMetric('gpu-status', webglCtx ? 'Available' : 'Not Available');
            } catch (e) {
                tests.push({
                    name: 'WebGL Context',
                    result: false,
                    details: 'Error: ' + e.message
                });
                updateMetric('gpu-status', 'Error');
            }
            
            // Test image smoothing
            tests.push({
                name: 'Image Smoothing',
                result: 'imageSmoothingEnabled' in ctx,
                details: ctx.imageSmoothingEnabled ? 'Enabled' : 'Disabled'
            });
            
            // Test filter support
            ctx.filter = 'contrast(1.5)';
            tests.push({
                name: 'CSS Filters',
                result: ctx.filter === 'contrast(1.5)',
                details: ctx.filter === 'contrast(1.5)' ? 'Supported' : 'Not supported'
            });
            ctx.filter = 'none';
            
            // Display test results
            displayTestResults(tests);
        }
        
        function setupEventListeners() {
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
        }
        
        function startTest() {
            if (testRunning) return;
            
            testRunning = true;
            frameCount = 0;
            startTime = performance.now();
            updateStatus('Performance test running...');
            updateMetric('test-status', 'Running');
            
            // Start animation loop
            animate();
        }
        
        function stopTest() {
            testRunning = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            updateStatus('Performance test stopped');
            updateMetric('test-status', 'Stopped');
        }
        
        function animate() {
            if (!testRunning) return;
            
            const now = performance.now();
            const renderStart = now;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw test pattern
            drawTestPattern();
            
            // Calculate performance metrics
            const renderTime = performance.now() - renderStart;
            renderTimes.push(renderTime);
            
            if (lastFrameTime > 0) {
                const frameTime = now - lastFrameTime;
                const fps = 1000 / frameTime;
                frameRates.push(fps);
                
                updateMetric('fps', fps.toFixed(1));
            }
            
            updateMetric('render-time', renderTime.toFixed(2) + 'ms');
            
            // Keep only last 60 measurements
            if (renderTimes.length > 60) renderTimes.shift();
            if (frameRates.length > 60) frameRates.shift();
            
            frameCount++;
            lastFrameTime = now;
            
            animationFrame = requestAnimationFrame(animate);
        }
        
        function drawTestPattern() {
            const time = performance.now() * 0.001;
            
            // Draw animated test pattern
            for (let x = 0; x < canvas.width; x += 20) {
                for (let y = 0; y < canvas.height; y += 20) {
                    const intensity = Math.sin(x * 0.01 + time) * Math.cos(y * 0.01 + time);
                    const color = Math.floor((intensity + 1) * 127);
                    
                    ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                    ctx.fillRect(x, y, 15, 15);
                }
            }
            
            // Draw crosshair
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 - 20, canvas.height / 2);
            ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, canvas.height / 2 - 20);
            ctx.lineTo(canvas.width / 2, canvas.height / 2 + 20);
            ctx.stroke();
        }
        
        function generateTestImage() {
            const imageData = ctx.createImageData(512, 512);
            const data = imageData.data;
            
            // Generate test DICOM-like image
            for (let i = 0; i < data.length; i += 4) {
                const x = (i / 4) % 512;
                const y = Math.floor((i / 4) / 512);
                
                // Create medical image pattern
                const centerX = 256;
                const centerY = 256;
                const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                
                let value;
                if (distance < 100) {
                    value = 200 + Math.sin(distance * 0.1) * 50; // Bright center
                } else if (distance < 200) {
                    value = 100 + Math.cos(distance * 0.05) * 30; // Medium ring
                } else {
                    value = 50; // Dark background
                }
                
                data[i] = value;     // R
                data[i + 1] = value; // G  
                data[i + 2] = value; // B
                data[i + 3] = 255;   // A
            }
            
            // Clear canvas and draw test image
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create temporary canvas for the image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 512;
            tempCanvas.height = 512;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            // Apply medical imaging filters
            ctx.filter = 'contrast(1.9) brightness(2.2) saturate(0.9)';
            
            // Draw scaled to fit
            const scale = Math.min(canvas.width / 512, canvas.height / 512) * 0.8;
            const x = (canvas.width - 512 * scale) / 2;
            const y = (canvas.height - 512 * scale) / 2;
            
            ctx.drawImage(tempCanvas, x, y, 512 * scale, 512 * scale);
            ctx.filter = 'none';
            
            currentImage = tempCanvas;
            updateMetric('image-status', 'Test Image Loaded');
            updateStatus('Test medical image generated');
            logPerformance('Generated test medical image');
        }
        
        function drawImage() {
            if (!currentImage) return;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply medical imaging filters
            ctx.filter = 'contrast(1.9) brightness(2.2) saturate(0.9)';
            
            const scale = Math.min(canvas.width / currentImage.width, canvas.height / currentImage.height) * 0.9;
            const x = (canvas.width - currentImage.width * scale) / 2;
            const y = (canvas.height - currentImage.height * scale) / 2;
            
            ctx.drawImage(currentImage, x, y, currentImage.width * scale, currentImage.height * scale);
            ctx.filter = 'none';
        }
        
        function testZoom() {
            if (!currentImage) {
                generateTestImage();
                setTimeout(testZoom, 100);
                return;
            }
            
            // Animate zoom test
            let scale = 0.5;
            const zoomTest = () => {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.filter = 'contrast(1.9) brightness(2.2) saturate(0.9)';
                
                const drawScale = Math.min(canvas.width / currentImage.width, canvas.height / currentImage.height) * scale;
                const x = (canvas.width - currentImage.width * drawScale) / 2;
                const y = (canvas.height - currentImage.height * drawScale) / 2;
                
                ctx.drawImage(currentImage, x, y, currentImage.width * drawScale, currentImage.height * drawScale);
                ctx.filter = 'none';
                
                scale += 0.05;
                if (scale < 2.0) {
                    requestAnimationFrame(zoomTest);
                }
            };
            
            zoomTest();
            updateStatus('Zoom test completed');
            logPerformance('Zoom test - smooth scaling');
        }
        
        function testPan() {
            if (!currentImage) {
                generateTestImage();
                setTimeout(testPan, 100);
                return;
            }
            
            // Animate pan test
            let offset = 0;
            const panTest = () => {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.filter = 'contrast(1.9) brightness(2.2) saturate(0.9)';
                
                const scale = Math.min(canvas.width / currentImage.width, canvas.height / currentImage.height) * 0.8;
                const x = (canvas.width - currentImage.width * scale) / 2 + Math.sin(offset * 0.1) * 50;
                const y = (canvas.height - currentImage.height * scale) / 2 + Math.cos(offset * 0.1) * 30;
                
                ctx.drawImage(currentImage, x, y, currentImage.width * scale, currentImage.height * scale);
                ctx.filter = 'none';
                
                offset++;
                if (offset < 60) {
                    requestAnimationFrame(panTest);
                }
            };
            
            panTest();
            updateStatus('Pan test completed');
            logPerformance('Pan test - smooth movement');
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            currentImage = null;
            updateMetric('image-status', 'No Image');
            updateStatus('Canvas cleared');
        }
        
        // Event handlers
        function handleMouseDown(e) {
            interactions++;
            updateMetric('interactions', interactions);
            updateMetric('last-action', 'Mouse Down');
        }
        
        function handleMouseMove(e) {
            // Only count if mouse is down
            if (e.buttons > 0) {
                updateMetric('last-action', 'Mouse Drag');
            }
        }
        
        function handleMouseUp(e) {
            updateMetric('last-action', 'Mouse Up');
        }
        
        function handleWheel(e) {
            e.preventDefault();
            interactions++;
            updateMetric('interactions', interactions);
            updateMetric('last-action', 'Wheel Scroll');
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            interactions++;
            updateMetric('interactions', interactions);
            updateMetric('last-action', 'Touch Start');
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            updateMetric('last-action', 'Touch Move');
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            updateMetric('last-action', 'Touch End');
        }
        
        function handleKeyDown(e) {
            interactions++;
            updateMetric('interactions', interactions);
            updateMetric('last-action', `Key: ${e.key}`);
            
            // Handle shortcuts
            switch (e.key) {
                case 's':
                    startTest();
                    break;
                case 'x':
                    stopTest();
                    break;
                case 'g':
                    generateTestImage();
                    break;
                case 'c':
                    clearCanvas();
                    break;
            }
        }
        
        function startPerformanceMonitoring() {
            setInterval(() => {
                updateMemoryMetric();
                
                // Calculate average performance
                if (renderTimes.length > 0) {
                    const avgRenderTime = renderTimes.reduce((a, b) => a + b) / renderTimes.length;
                    if (avgRenderTime > 16.67) {
                        document.getElementById('render-time').parentElement.className = 'metric warning';
                    } else {
                        document.getElementById('render-time').parentElement.className = 'metric';
                    }
                }
                
                if (frameRates.length > 0) {
                    const avgFps = frameRates.reduce((a, b) => a + b) / frameRates.length;
                    if (avgFps < 30) {
                        document.getElementById('fps').parentElement.className = 'metric warning';
                    } else {
                        document.getElementById('fps').parentElement.className = 'metric';
                    }
                }
            }, 1000);
        }
        
        function updateMemoryMetric() {
            if (performance.memory) {
                const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                updateMetric('memory', memoryMB + 'MB');
                
                if (performance.memory.usedJSHeapSize > 100 * 1024 * 1024) { // 100MB
                    document.getElementById('memory').parentElement.className = 'metric warning';
                } else {
                    document.getElementById('memory').parentElement.className = 'metric';
                }
            } else {
                updateMetric('memory', 'Not Available');
            }
        }
        
        function updateMetric(id, value) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function logPerformance(message) {
            const timestamp = new Date().toLocaleTimeString();
            performanceLog.push(`[${timestamp}] ${message}`);
            
            if (performanceLog.length > 20) {
                performanceLog.shift();
            }
            
            const logElement = document.getElementById('performance-log');
            logElement.innerHTML = performanceLog.map(log => `<div>${log}</div>`).join('');
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function displayTestResults(tests) {
            const resultsElement = document.getElementById('test-results');
            resultsElement.innerHTML = tests.map(test => {
                const status = test.result ? '✅' : '❌';
                const className = test.result ? 'metric' : 'metric error';
                return `<div class="${className}">${status} ${test.name}: ${test.details}</div>`;
            }).join('');
        }
        
        // Auto-start logging
        logPerformance('Performance monitoring started');
        logPerformance('Canvas capabilities tested');
    </script>
</body>
</html>